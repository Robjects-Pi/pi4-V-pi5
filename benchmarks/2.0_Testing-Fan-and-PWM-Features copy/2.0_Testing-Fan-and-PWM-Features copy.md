## Basic Components and Details

### Introduction
Welcome to the benchmarking documentation for the pi4-V-pi5 project. In this document, we will discuss the basic components and details of the benchmarking process.

### Hardware Requirements
To perform the benchmarks, you will need the following hardware components:
- Raspberry Pi 4 Model B
- Raspberry Pi 5 Model B
- Power supply
- MicroSD card
- Ethernet cable
- HDMI cable
- Monitor

### Software Requirements
Make sure you have the following software installed on your Raspberry Pi devices:
- Raspbian OS
- Python 3
- Git

### Benchmarking Methodology
The benchmarking process involves the following steps:
1. Clone the pi4-V-pi5 repository from GitHub.
2. Set up the Raspberry Pi 4 and Raspberry Pi 5 devices.
3. Install the necessary dependencies.
4. Run the benchmarking script.
5. Analyze the results.

### Benchmarking Script
The benchmarking script is located in the `benchmarks` directory of the pi4-V-pi5 repository. It is written in Python and measures the performance of various components on both Raspberry Pi models.

### Results Analysis
After running the benchmarking script, you will obtain a set of results. Analyze these results to compare the performance of the Raspberry Pi 4 and Raspberry Pi 5 devices. Look for any significant differences or improvements.

### Conclusion
In this document, we have covered the basic components and details of the benchmarking process for the pi4-V-pi5 project. Follow the steps outlined here to accurately measure and compare the performance of the Raspberry Pi 4 and Raspberry Pi 5 devices.



## Benchmark 3: Resource Utilization & Reliability

## Benchmark 3.1: Resource Utilization

### Introduction
- **Goals and Objectives**: Measure the system's resource utilization under various conditions.
- **System Configuration**: Same as Benchmark 1, with additional monitoring of CPU temperature and clock speed.

### Methodology
- **Process**: Tools used include Sysbench, Stress-ng, and Vcgencmd for monitoring.
- **Test Scenarios**: Various workloads to measure CPU, memory, and I/O utilization.

### Results
- **Data Presentation**: Include graphs and tables showing resource utilization metrics.
- **Analysis**: Highlight key findings such as resource usage patterns and inefficiencies.

### Discussion
- **Interpretation**: Discuss the system's resource utilization and any inefficiencies identified.
- **Bottlenecks**: Identify specific areas where resource utilization was suboptimal, such as high CPU temperatures or memory bottlenecks.

### Conclusion and Recommendations
- **Summary**: Recap the main findings of the benchmark.
- **Recommendations**: Suggest optimizations such as better cooling solutions or memory management improvements.
 

## Benchmark 3: Resource Utilization

### Introduction
- **Goals and Objectives**: Measure the system's resource utilization under various conditions.
- **System Configuration**: Same as Benchmark 1, with additional monitoring of CPU temperature and clock speed.

### Methodology
- **Process**: Tools used include Sysbench, Stress-ng, and Vcgencmd for monitoring.
- **Test Scenarios**: Various workloads to measure CPU, memory, and I/O utilization.

### Results
- **Data Presentation**: Include graphs and tables showing resource utilization metrics.
- **Analysis**: Highlight key findings such as resource usage patterns and inefficiencies.

### Discussion
- **Interpretation**: Discuss the system's resource utilization and any inefficiencies identified.
- **Bottlenecks**: Identify specific areas where resource utilization was suboptimal, such as high CPU temperatures or memory bottlenecks.

### Conclusion and Recommendations
- **Summary**: Recap the main findings of the benchmark.
- **Recommendations**: Suggest optimizations such as better cooling solutions or memory management improvements.

## Benchmark 3.2: Reliability

### Introduction
- **Goals and Objectives**: Evaluate the system's reliability under prolonged use.
- **System Configuration**: Same as Benchmark 1, with extended testing periods.

### Methodology
- **Process**: Tools used include Stress-ng and monitoring scripts for reliability tests.
- **Test Scenarios**: Prolonged stress tests to evaluate system stability and reliability.

### Results
- **Data Presentation**: Include graphs and tables showing reliability metrics.
- **Analysis**: Highlight key findings such as system stability and any failures observed.

### Discussion
- **Interpretation**: Discuss the system's reliability and any issues identified.
- **Bottlenecks**: Identify specific areas where reliability was compromised, such as hardware failures or software crashes.

### Conclusion and Recommendations
- **Summary**: Recap the main findings of the benchmark.
- **Recommendations**: Suggest improvements such as hardware upgrades or software patches to enhance reliability.


## Benchmark 3.3: HDMI and USB I/O Performance

### Introduction
- **Goals and Objectives**: Evaluate the performance of HDMI output and USB I/O file transfers on Raspberry Pi 4 and Raspberry Pi 5.
- **System Configuration**: Both Raspberry Pi 4 and Raspberry Pi 5 are brand new, running the latest version of Raspberry Pi OS (64-bit) with all updates installed. Both devices are powered by their respective power supplies (3 A vs 5 A) and connected to the same network using wireless connections.

### Methodology
- **Process**: Tools used include custom scripts for HDMI lag measurement and USB I/O performance tests.
- **Test Scenarios**:
  - **HDMI Lag Measurement**: Generate a small white square on the screen and measure the input lag using a photosensor.
  - **USB I/O File Transfers**: Measure transfer speeds using various USB 3.0 devices and configurations.

### Results
- **Data Presentation**: Include graphs and tables showing HDMI lag times and USB transfer speeds.
- **Analysis**: Highlight key findings such as differences in HDMI lag and USB I/O performance between Raspberry Pi 4 and Raspberry Pi 5.

### Discussion
- **Interpretation**: Discuss the system's HDMI and USB I/O performance and any issues identified.
- **Bottlenecks**: Identify specific areas where performance was suboptimal, such as USB controller limitations or HDMI processing delays.

### Conclusion and Recommendations
- **Summary**: Recap the main findings of the benchmark.
- **Recommendations**: Suggest improvements such as optimized USB configurations or enhanced HDMI processing techniques.

### Quick Instructions for HDMI and USB I/O Performance Tests

**HDMI Lag Measurement Script:**

Create a script named `hdmi_lag_test.sh` with the following content:

```bash
#!/bin/bash

# Generate a white square on the screen
# This part will depend on the specific method used to generate the square
# Example using Python and Pygame (ensure Pygame is installed)
python3 -c "
import pygame
import time
pygame.init()
screen = pygame.display.set_mode((800, 600))
white = (255, 255, 255)
screen.fill((0, 0, 0))
pygame.display.flip()
time.sleep(1)
start_time = time.time()
pygame.draw.rect(screen, white, pygame.Rect(350, 250, 100, 100))
pygame.display.flip()
end_time = time.time()
print('HDMI Lag:', end_time - start_time, 'seconds')
" | tee hdmi_lag_test.txt
```

**USB I/O Performance Test Script:**

Create a script named `usb_io_test.sh` with the following content:

```bash
#!/bin/bash

# Test USB read and write speeds
output_file="usb_io_test.csv"
echo "Test,Transfer Rate (MB/s)" > "$output_file"

# Write Test
write_speed=$(dd if=/dev/zero of=/mnt/usb/testfile bs=1M count=1024 conv=fdatasync 2>&1 | grep -o '[0-9.]* MB/s')
echo "Write,$write_speed" >> "$output_file"

# Read Test
read_speed=$(dd if=/mnt/usb/testfile of=/dev/null bs=1M 2>&1 | grep -o '[0-9.]* MB/s')
echo "Read,$read_speed" >> "$output_file"

cat "$output_file" | tee usb_io_test.txt
```

**Run the Scripts:**

```bash
chmod +x hdmi_lag_test.sh usb_io_test.sh
./hdmi_lag_test.sh
./usb_io_test.sh
```

## How to Access the Benchmark Results

The detailed results and analysis of each benchmark are available in the following sections of this document. Readers are encouraged to review each section to gain a comprehensive understanding of the system's performance characteristics.

## Acknowledgments

We would like to thank all the contributors and participants who made these benchmarks possible. Their dedication and hard work have provided valuable insights into the system's performance.
